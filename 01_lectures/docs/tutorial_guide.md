# AI × Game Development Tutorial
## はじめてでも分かる「ゲームが動く仕組み」と「AIが考える仕組み」

---

## この資料について

この資料は、

> **「ゲームを作ったことがない人」
> 「AIやプログラミングが初めての人」**

を想定しています。

途中で出てくる言葉（State / DSL / AST など）は、
**最初は知らなくて当たり前**です。

この資料では、次の約束をします。

- 分からない言葉は **必ず説明する**
- 「それって何のためにあるの？」を **必ず答える**
- いきなり賢くならなくていい → **順番に"分かるようになる"**

---

## まず大前提：この教材でやりたいこと

この教材の目的は、**ゲームを完成させること**ではありません。

本当の目的はこれです。

> **ゲームやAIが
> 「なぜその動きをしたのか」を
> 自分の言葉で説明できるようになること**

そのために、ゲームを使って、

- 状態とは何か
- ルールとは何か
- AIはどうやって「考えたつもり」になるのか

を、**目で見て、触って、壊しながら**学びます。

---

## この教材の全体像

この教材は、**9つのStep**で構成されています。

| Step | 名前 | 学ぶこと |
|------|------|----------|
| 00 | Hello World | 環境確認・最初の一歩 |
| 01 | Game Loop | ゲームの「心臓」を理解する |
| 02 | State | 「今どうなってる？」を管理する |
| 03 | I/O | 入力と出力を分離する |
| 04 | Renderer | 画面に描く「純粋関数」 |
| 05 | Lexer | 文字列を「単語」に分ける |
| 06 | Parser | 単語を「意味のある木」にする |
| 07 | Interpreter | 木を「実行」する |
| 08 | AI (A*) | AIが「考える」仕組み |

---

## Step 00: Hello World（環境確認）

### 目的
- Pythonが動くことを確認する
- ゲームを起動してみる
- w/a/s/d で動かしてみる

### やってみよう

```bash
cd 02_tutorial
python3 run.py
```

1. 「New Game」を選ぶ
2. 「Step 00: Hello World」を選ぶ
3. SAVE_A に保存
4. `w` を押す → `@` が上に動く！

### ここで覚えること

- `@` がプレイヤー
- w/a/s/d で上下左右に動く
- quit で終了

**成功したら、あなたはもう「ゲームをプレイした」のです！**

---

## Step 01: Game Loop（ゲームループ）

### これは何？

ゲームは、この3つを**ひたすら繰り返す**ことで動きます。

```
1. 入力を受け取る（キー押下）
2. 状態を更新する（キャラを動かす）
3. 画面を描く（結果を表示）
→ 1に戻る
```

これを**ゲームループ**と呼びます。

### 体験してみよう

Step 01 は「カウンター」です。

- `up` または `+` → 数字が増える
- `down` または `-` → 数字が減る
- `reset` → 0に戻る

```
=== Counter Game ===
Count: 5

Commands: up(+), down(-), reset, quit
```

### なぜカウンター？

ゲームじゃないじゃん、と思いましたか？

でも実は、これが**ゲームの本質**なんです。

- 入力：`up` を押した
- 更新：`count = count + 1`
- 描画：`Count: 5` と表示

RPGでHPが減るのも、スコアが増えるのも、全部これと同じです。

---

## Step 02: State（状態管理）

### 「状態」って何？

ゲームの「今どうなってるか」を表すデータです。

```python
state = {
    "player": {"x": 10, "y": 5, "hp": 100},
    "enemies": [...],
    "turn": 0,
    "score": 0,
}
```

### なぜ「状態」を分けるの？

ゲームでよくあるバグ：

> 「なんか変な動きした」
> 「再現できない」
> 「何が起きたか分からない」

これは、**状態がどこからでも変更できる**と起きやすい。

### この教材の設計方針：イミュータブル（不変）

```python
# 古い状態を変更するのではなく
old_state.player.x = 11  # ❌ ダメ

# 新しい状態を作る
new_state = old_state.move_player(1, 0)  # ✓ 良い
```

「今の状態」と「次の状態」を明確に分けることで、

- 何が起きたか追跡しやすい
- バグの原因を見つけやすい
- 「undo」も簡単に作れる

---

## Step 03: I/O（入出力の分離）

### これは何？

**ゲームロジック**と**入出力**を分ける設計です。

```
[入力] → [ゲームロジック] → [出力]
         ここだけ純粋！
```

### なぜ分けるの？

ゲームロジックを**純粋にする**と：

- テストが簡単になる（キーボードなしでテストできる）
- 再利用しやすい（Web版でもCLI版でも同じロジック）
- バグが見つけやすい（入出力のバグとロジックのバグを切り分けられる）

### 純粋関数とは？

```python
# 純粋関数：同じ入力なら必ず同じ出力
def add(a, b):
    return a + b  # 常に a + b を返す

# 純粋でない関数：結果が変わるかも
def get_time():
    return datetime.now()  # 呼ぶたびに違う値
```

---

## Step 04: Renderer（レンダラー）

### これは何？

状態を**見える形**に変換する関数です。

```python
def render(state) -> str:
    """状態を文字列に変換する（副作用なし！）"""
    grid = TextGrid(20, 10)
    grid.set(state.player.x, state.player.y, "@")
    return grid.render()
```

### ポイント

1. **入力**：ゲームの状態（state）
2. **出力**：描画結果の文字列
3. **副作用なし**：print しない！

```
######################
#..........@.........#
#....................#
#....................#
#........E...........#
#....................#
######################
```

### なぜ「文字列を返す」だけ？

`print()` を中でやらないのは、

- テストしやすい（結果を文字列として比較できる）
- 出力先を選べる（画面、ファイル、ネットワーク）
- 複数フレームをまとめて処理できる

---

## Step 05: Lexer（字句解析）

### ここからDSLの世界

「DSL」= Domain Specific Language（ドメイン特化言語）

ゲームを操作するための**小さな言語**を作ります。

### 例

```
move player 5 3
```

これを**トークン**に分解します：

```
Token(IDENTIFIER, "move")
Token(IDENTIFIER, "player")
Token(NUMBER, 5)
Token(NUMBER, 3)
```

### なぜトークンに分ける？

人間が書いた文字列は、プログラムにとって「ただの文字の並び」です。

```
"move player 5 3"
```

これを意味のある単位に分けるのが**Lexer（レクサー）**の仕事。

```
["move", "player", "5", "3"]
→ それぞれに「種類」をつける
→ IDENTIFIER, IDENTIFIER, NUMBER, NUMBER
```

---

## Step 06: Parser（構文解析）

### これは何？

トークンを**構文木（AST）**に変換します。

### 例

```
move player 5 3
```

↓ Parser で変換

```
MoveCommand(
    target="player",
    x=5,
    y=3
)
```

### なぜ木構造？

条件文のような複雑な構造を表現できます：

```
if player.hp < 50 then set player.state danger
```

↓

```
IfCommand(
    condition=Comparison(
        left=PropertyAccess("player", "hp"),
        op="<",
        right=50
    ),
    then=SetCommand(
        target=PropertyAccess("player", "state"),
        value="danger"
    )
)
```

---

## Step 07: Interpreter（インタプリタ）

### これは何？

ASTを**実行**して、ゲームの状態を変更します。

### 流れ

```
1. 入力: "move player 5 3"
2. Lexer: トークンに分解
3. Parser: ASTに変換
4. Interpreter: 状態を更新！
```

```python
# Interpreterの仕事
def execute(ast, state):
    if isinstance(ast, MoveCommand):
        new_pos = Position(ast.x, ast.y)
        return state.move_player_to(new_pos)
    ...
```

### Step 07 で使えるコマンド

| コマンド | 説明 |
|----------|------|
| `move player <x> <y>` | プレイヤーを座標(x,y)に移動 |
| `spawn enemy <x> <y>` | 敵を生成 |
| `destroy <target>` | エンティティを削除 |
| `set <entity>.<prop> <value>` | プロパティを設定 |
| `if <cond> then <action>` | 条件分岐 |
| `wait` | AIターンを実行 |

---

## Step 08: AI（A*経路探索）

### ついにAI！

AIが「考える」とは何でしょうか？

この教材では、**A*アルゴリズム**を使って、
敵がプレイヤーを追いかける仕組みを作ります。

### A*アルゴリズムとは

「最短経路」を見つけるアルゴリズムです。

```
S = Start（敵の位置）
G = Goal（プレイヤーの位置）
# = 壁（通れない）
* = 経路

S........#....
.***....#....
...***..#....
......**#....
........#..**G
```

### AIは「考えて」いるのか？

AIがやっていることは、実はとてもシンプルです：

1. 現在位置とゴールを確認
2. 行ける場所を全部リストアップ
3. 「ゴールに近づける場所」を優先して選ぶ
4. これを繰り返す

**「考えている」ように見えますが、
実際は「ルール通りに計算している」だけです。**

---

## 各Stepの操作方法まとめ

| Step | Mode | 操作 |
|------|------|------|
| 00 | WELCOME | `w/a/s/d` で移動 |
| 01 | LOOP | `up/+` `down/-` `reset` |
| 02 | STATE | `w/a/s/d` で移動 |
| 03 | IO | `w/a/s/d` で移動 |
| 04 | RENDERER | `w/a/s/d` で移動 |
| 05 | LEXER | DSLコマンド（トークン表示） |
| 06 | PARSER | DSLコマンド（AST表示） |
| 07-08 | INTERPRETER | DSLコマンド（実行） |

---

## よく出る用語集

| 用語 | 意味 |
|------|------|
| State | ゲームの「今の状態」を表すデータ |
| Immutable | 変更不可。新しいものを作る |
| Pure Function | 同じ入力なら必ず同じ出力。副作用なし |
| DSL | ドメイン特化言語。ゲーム専用コマンド |
| Token | 文字列を意味のある単位に分けたもの |
| AST | 抽象構文木。プログラムの構造を表す木 |
| Lexer | 文字列→トークン |
| Parser | トークン→AST |
| Interpreter | AST→実行 |
| A* | 最短経路を見つけるアルゴリズム |

---

## 学習の進め方

### 推奨順序

1. **Step 00-04**：ゲームの基礎を理解
   - 手を動かして、@を動かす
   - 「状態が変わる」ことを体感する

2. **Step 05-07**：DSLを理解
   - コマンドがどう処理されるか見る
   - Lexer → Parser → Interpreter の流れを追う

3. **Step 08**：AIを体験
   - `wait` コマンドで敵を動かす
   - AIがどうやって「追いかけてくる」か観察する

### 壊して学ぼう

- `examples/` フォルダの各 `main.py` を直接実行できます
- コードを変更して、何が変わるか見てみましょう
- 「なぜそう動くのか」を自分の言葉で説明してみましょう

---

## 起動方法

```bash
# 統合環境（推奨）
cd 02_tutorial
python3 run.py

# 各Stepを個別に実行
python3 examples/step_01_game_loop/main.py
python3 examples/step_02_state/main.py
# ... 他のStepも同様
```

---

## 次のステップ

この教材を終えたら、次のことに挑戦してみてください。

1. **新しいコマンドを追加する**
   - DSLに `heal player` コマンドを追加

2. **AIを賢くする**
   - 障害物を避けながら追いかける
   - 複数の敵が協力して挟み撃ち

3. **ルールを変える**
   - HPが0になったらゲームオーバー
   - アイテムを拾うとスコアが増える

4. **見た目を変える**
   - 色をつける（curses ライブラリ）
   - ターミナルを超えてGUIにする

---

## まとめ

この教材で学んだこと：

1. **ゲームループ**：入力→更新→描画の繰り返し
2. **状態管理**：イミュータブルに管理する
3. **DSL**：Lexer → Parser → Interpreter
4. **AI**：ルール通りに計算しているだけ

**「なぜその動きをしたのか」を説明できるようになりましたか？**

できるようになったら、あなたはもう、
**ゲームとAIの「仕組み」を理解した人**です。

おめでとうございます！

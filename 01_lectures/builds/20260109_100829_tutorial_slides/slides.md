---
marp: true
theme: default
paginate: true
backgroundColor: #1a1a2e
color: #eaeaea
style: |
  section {
    font-family: 'Hiragino Sans', 'Meiryo', sans-serif;
  }
  h1 {
    color: #00d4ff;
  }
  h2 {
    color: #ff6b6b;
  }
  code {
    background: #2d2d44;
  }
  table {
    font-size: 0.8em;
  }
---

# AI × Game Development Tutorial

## はじめてでも分かる
## 「ゲームが動く仕組み」と「AIが考える仕組み」

**久留米工業大学 2026**

---

# この資料について

この資料は、

> **「ゲームを作ったことがない人」**
> **「AIやプログラミングが初めての人」**

を想定しています。

---

# お約束

- 分からない言葉は **必ず説明する**
- 「それって何のためにあるの？」を **必ず答える**
- いきなり賢くならなくていい
  → **順番に"分かるようになる"**

---

# この教材の本当の目的

**ゲームを完成させること**ではありません。

本当の目的は...

---

# 本当の目的

> **ゲームやAIが
> 「なぜその動きをしたのか」を
> 自分の言葉で説明できるようになること**

---

# 学ぶこと

- **状態**とは何か
- **ルール**とは何か
- AIはどうやって「考えたつもり」になるのか

を、**目で見て、触って、壊しながら**学びます。

---

# 全体像：9つのStep

| Step | 名前 | 学ぶこと |
|------|------|----------|
| 00 | Hello World | 環境確認・最初の一歩 |
| 01 | Game Loop | ゲームの「心臓」 |
| 02 | State | 「今どうなってる？」 |
| 03 | I/O | 入力と出力を分離 |
| 04 | Renderer | 画面に描く |

---

# 全体像：9つのStep（続き）

| Step | 名前 | 学ぶこと |
|------|------|----------|
| 05 | Lexer | 文字列→単語 |
| 06 | Parser | 単語→木構造 |
| 07 | Interpreter | 木→実行 |
| 08 | AI (A*) | AIが「考える」仕組み |

---

<!-- _backgroundColor: #0f3460 -->

# Step 00
## Hello World
### 環境確認

---

# Step 00: 目的

- Pythonが動くことを確認
- ゲームを起動してみる
- w/a/s/d で動かしてみる

---

# Step 00: やってみよう

```bash
cd 02_tutorial
python3 run.py
```

1. 「New Game」を選ぶ
2. 「Step 00: Hello World」を選ぶ
3. SAVE_A に保存
4. `w` を押す

---

# Step 00: 結果

```
######################
#..........@.........#
#....................#
#....................#
######################
```

**`@` が上に動いた！**

---

# Step 00: 覚えること

- `@` がプレイヤー
- `w/a/s/d` で上下左右に動く
- `quit` で終了

**成功したら、あなたはもう「ゲームをプレイした」のです！**

---

<!-- _backgroundColor: #0f3460 -->

# Step 01
## Game Loop
### ゲームループ

---

# ゲームループとは？

ゲームは、この3つを**ひたすら繰り返す**ことで動きます。

```
1. 入力を受け取る（キー押下）
       ↓
2. 状態を更新する（キャラを動かす）
       ↓
3. 画面を描く（結果を表示）
       ↓
    1に戻る
```

---

# Step 01: カウンターゲーム

```
=== Counter Game ===
Count: 5

Commands: up(+), down(-), reset, quit
```

- `up` または `+` → 数字が増える
- `down` または `-` → 数字が減る
- `reset` → 0に戻る

---

# なぜカウンター？

「ゲームじゃない」と思いましたか？

でも実は、これが**ゲームの本質**です。

- **入力**：`up` を押した
- **更新**：`count = count + 1`
- **描画**：`Count: 5` と表示

---

# RPGも同じ

- HPが減る
- スコアが増える
- レベルが上がる

全部「状態の数値を変える」だけ！

---

<!-- _backgroundColor: #0f3460 -->

# Step 02
## State
### 状態管理

---

# 「状態」って何？

ゲームの「今どうなってるか」を表すデータです。

```python
state = {
    "player": {"x": 10, "y": 5, "hp": 100},
    "enemies": [...],
    "turn": 0,
    "score": 0,
}
```

---

# よくあるバグ

> 「なんか変な動きした」
> 「再現できない」
> 「何が起きたか分からない」

原因：**状態がどこからでも変更できる**

---

# 解決策：イミュータブル（不変）

```python
# ❌ 古い状態を変更する
old_state.player.x = 11

# ✓ 新しい状態を作る
new_state = old_state.move_player(1, 0)
```

---

# イミュータブルのメリット

- 何が起きたか**追跡しやすい**
- バグの原因を**見つけやすい**
- 「Undo」も**簡単に作れる**

---

<!-- _backgroundColor: #0f3460 -->

# Step 03
## I/O Separation
### 入出力の分離

---

# 入出力の分離とは？

**ゲームロジック**と**入出力**を分ける設計

```
[入力] → [ゲームロジック] → [出力]
         ここだけ純粋！
```

---

# なぜ分けるの？

ゲームロジックを**純粋にする**と：

- テストが簡単（キーボードなしでテスト）
- 再利用しやすい（Web版でもCLI版でも同じ）
- バグが見つけやすい

---

# 純粋関数とは？

```python
# ✓ 純粋関数：同じ入力なら必ず同じ出力
def add(a, b):
    return a + b

# ❌ 純粋でない関数：結果が変わる
def get_time():
    return datetime.now()
```

---

<!-- _backgroundColor: #0f3460 -->

# Step 04
## Renderer
### レンダラー

---

# レンダラーとは？

状態を**見える形**に変換する関数

```python
def render(state) -> str:
    """状態を文字列に変換する（副作用なし！）"""
    grid = TextGrid(20, 10)
    grid.set(state.player.x, state.player.y, "@")
    return grid.render()
```

---

# 出力例

```
######################
#..........@.........#
#....................#
#........E...........#
#....................#
######################
```

---

# ポイント

1. **入力**：ゲームの状態（state）
2. **出力**：描画結果の文字列
3. **副作用なし**：print しない！

---

# なぜ「文字列を返す」だけ？

- テストしやすい（文字列として比較）
- 出力先を選べる（画面、ファイル、ネットワーク）
- 複数フレームをまとめて処理できる

---

<!-- _backgroundColor: #16213e -->

# ここまでのまとめ
## Step 00-04

---

# Step 00-04 で学んだこと

| Step | 学んだこと |
|------|------------|
| 00 | 環境確認、w/a/s/d移動 |
| 01 | ゲームループ（入力→更新→描画） |
| 02 | 状態管理（イミュータブル） |
| 03 | 入出力の分離（純粋関数） |
| 04 | レンダラー（状態→文字列） |

---

<!-- _backgroundColor: #0f3460 -->

# Step 05
## Lexer
### 字句解析

---

# ここからDSLの世界

**DSL** = Domain Specific Language
（ドメイン特化言語）

ゲームを操作するための**小さな言語**を作ります。

---

# 例

```
move player 5 3
```

これを**トークン**に分解します：

```
Token(IDENTIFIER, "move")
Token(IDENTIFIER, "player")
Token(NUMBER, 5)
Token(NUMBER, 3)
```

---

# なぜトークンに分ける？

人間が書いた文字列は、
プログラムにとって「ただの文字の並び」

```
"move player 5 3"
```

意味のある単位に分けるのが**Lexer**の仕事

---

<!-- _backgroundColor: #0f3460 -->

# Step 06
## Parser
### 構文解析

---

# Parserとは？

トークンを**構文木（AST）**に変換

```
move player 5 3
```
↓ Parser
```
MoveCommand(
    target="player",
    x=5,
    y=3
)
```

---

# なぜ木構造？

条件文のような複雑な構造を表現できます：

```
if player.hp < 50 then set player.state danger
```

---

# ASTの例

```
IfCommand(
    condition=Comparison(
        left=PropertyAccess("player", "hp"),
        op="<",
        right=50
    ),
    then=SetCommand(...)
)
```

---

<!-- _backgroundColor: #0f3460 -->

# Step 07
## Interpreter
### インタプリタ

---

# Interpreterとは？

ASTを**実行**して、ゲームの状態を変更

---

# 処理の流れ

```
1. 入力: "move player 5 3"
       ↓
2. Lexer: トークンに分解
       ↓
3. Parser: ASTに変換
       ↓
4. Interpreter: 状態を更新！
```

---

# Step 07 で使えるコマンド

| コマンド | 説明 |
|----------|------|
| `move player <x> <y>` | 座標に移動 |
| `spawn enemy <x> <y>` | 敵を生成 |
| `destroy <target>` | 削除 |
| `wait` | AIターン |

---

<!-- _backgroundColor: #0f3460 -->

# Step 08
## AI (A*)
### 経路探索

---

# ついにAI！

AIが「考える」とは何でしょうか？

**A*アルゴリズム**を使って、
敵がプレイヤーを追いかける仕組みを作ります。

---

# A*アルゴリズムとは

「最短経路」を見つけるアルゴリズム

```
S = Start（敵の位置）
G = Goal（プレイヤーの位置）
# = 壁（通れない）
* = 経路

S........#....
.***....#....
...***..#....
......**#....
........#..**G
```

---

# AIは「考えて」いるのか？

やっていることは、とてもシンプル：

1. 現在位置とゴールを確認
2. 行ける場所を全部リストアップ
3. 「ゴールに近づける場所」を優先
4. これを繰り返す

---

# 重要な気づき

**「考えている」ように見えますが、
実際は「ルール通りに計算している」だけです。**

---

<!-- _backgroundColor: #16213e -->

# 操作方法まとめ

---

# 各Stepの操作

| Step | Mode | 操作 |
|------|------|------|
| 00-04 | 移動系 | `w/a/s/d` で移動 |
| 01 | LOOP | `up/+` `down/-` |
| 05 | LEXER | DSL（トークン表示） |
| 06 | PARSER | DSL（AST表示） |
| 07-08 | INTERPRETER | DSLコマンド |

---

<!-- _backgroundColor: #16213e -->

# 用語集

---

# 基本用語

| 用語 | 意味 |
|------|------|
| State | ゲームの「今の状態」 |
| Immutable | 変更不可、新しいものを作る |
| Pure Function | 同じ入力→同じ出力 |
| DSL | ドメイン特化言語 |

---

# DSL関連用語

| 用語 | 意味 |
|------|------|
| Token | 意味のある単位 |
| AST | 抽象構文木 |
| Lexer | 文字列→トークン |
| Parser | トークン→AST |
| Interpreter | AST→実行 |

---

<!-- _backgroundColor: #16213e -->

# 学習の進め方

---

# 推奨順序

1. **Step 00-04**：ゲームの基礎
   - `@`を動かす
   - 「状態が変わる」を体感

2. **Step 05-07**：DSLを理解
   - Lexer → Parser → Interpreter

3. **Step 08**：AIを体験
   - `wait` で敵を動かす

---

# 壊して学ぼう

- `examples/` の `main.py` を直接実行
- コードを変更して、何が変わるか見る
- 「なぜそう動くのか」を説明してみる

---

# 起動方法

```bash
# 統合環境（推奨）
cd 02_tutorial
python3 run.py

# 各Step個別実行
python3 examples/step_01_game_loop/main.py
python3 examples/step_02_state/main.py
```

---

<!-- _backgroundColor: #16213e -->

# まとめ

---

# この教材で学んだこと

1. **ゲームループ**：入力→更新→描画
2. **状態管理**：イミュータブル
3. **DSL**：Lexer → Parser → Interpreter
4. **AI**：ルール通りに計算

---

# 最後の質問

> **「なぜその動きをしたのか」
> 説明できるようになりましたか？**

---

# おめでとうございます！

できるようになったら、あなたはもう、

**ゲームとAIの「仕組み」を理解した人**

です。

---

# 次のステップ

- 新しいコマンドを追加する
- AIを賢くする
- ルールを変える
- 見た目を変える

**自分だけのゲームを作ってみよう！**

---

<!-- _backgroundColor: #1a1a2e -->

# Thank You!

## AI × Game Development Tutorial
### 久留米工業大学 2026
